import { useState, useEffect } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { z } from "zod";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle, 
  DialogDescription,
  DialogFooter
} from "@/components/ui/dialog";
import { 
  Form, 
  FormControl, 
  FormField, 
  FormItem, 
  FormLabel, 
  FormMessage 
} from "@/components/ui/form";
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from "@/components/ui/select";
import { Calendar } from "@/components/ui/calendar";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { formatDateForAPI } from "@/lib/utils/date-utils";
import { Room, User, Booking } from "@shared/schema";

// Esquema para el formulario de reserva
const bookingFormSchema = z.object({
  roomId: z.string().min(1, { message: "Selecciona un consultorio" }),
  userId: z.string().min(1, { message: "Selecciona un terapeuta" }),
  date: z.date({
    required_error: "Selecciona la fecha de la reserva",
  }).refine(
    (date) => {
      // No permitir fechas en el pasado
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      return date >= today;
    },
    { message: "No se pueden hacer reservas en fechas pasadas" }
  ),
  startTime: z.string().min(1, { message: "Selecciona la hora de inicio" }),
  endTime: z.string().min(1, { message: "Selecciona la hora de finalización" }),
  notes: z.string().optional(),
}).refine(
  (data) => {
    // Verifica si ambos campos tienen datos para hacer la comparación
    if (!data.startTime || !data.endTime) return true;
    
    // Extrae las horas para comparar
    const startHour = parseInt(data.startTime.split(":")[0]);
    const endHour = parseInt(data.endTime.split(":")[0]);
    
    // La hora final debe ser mayor que la inicial
    return endHour > startHour;
  },
  {
    message: "La hora de finalización debe ser posterior a la hora de inicio",
    path: ["endTime"], // mostrar el error en el campo de hora final
  }
);

type BookingFormValues = z.infer<typeof bookingFormSchema>;

// Horas de operación (de 8:00 AM a 8:00 PM)
const OPERATING_HOURS = [
  "8:00", "9:00", "10:00", "11:00", "12:00", "13:00", "14:00", 
  "15:00", "16:00", "17:00", "18:00", "19:00", "20:00"
];

interface BookingModalProps {
  isOpen: boolean;
  onClose: () => void;
  selectedDate?: Date;
  selectedRoomId?: number;
  onSuccess?: () => void;
}

export default function BookingModal({
  isOpen,
  onClose,
  selectedDate = new Date(),
  selectedRoomId,
  onSuccess
}: BookingModalProps) {
  console.log("BookingModal renderizado", { isOpen, selectedRoomId, selectedDate });
  
  // Agregamos un efecto para forzar que el modal esté abierto cuando se pasan props
  useEffect(() => {
    if (selectedRoomId) {
      console.log("Modal debe estar abierto porque hay un consultorio seleccionado:", selectedRoomId);
    }
  }, [selectedRoomId]);
  const { user } = useAuth();
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Consulta para obtener todos los consultorios
  const { data: rooms, isLoading: isLoadingRooms } = useQuery<Room[]>({
    queryKey: ['/api/rooms'],
    enabled: isOpen,
  });

  // Consulta para obtener todos los terapeutas
  const { data: users, isLoading: isLoadingUsers } = useQuery<User[]>({
    queryKey: ['/api/users'],
    enabled: isOpen,
  });

  // Formulario para crear reservas
  const form = useForm<BookingFormValues>({
    resolver: zodResolver(bookingFormSchema),
    defaultValues: {
      roomId: selectedRoomId ? String(selectedRoomId) : "",
      userId: user?.role === 'admin' ? "" : String(user?.id || ""),
      date: selectedDate,
      startTime: "",
      endTime: "",
      notes: "",
    },
  });

  // Actualizar el formulario cuando cambian las props
  useEffect(() => {
    if (isOpen) {
      console.log("Reseteando formulario con valores", { selectedRoomId, selectedDate });
      form.reset({
        roomId: selectedRoomId ? String(selectedRoomId) : "",
        userId: user?.role === 'admin' ? "" : String(user?.id || ""),
        date: selectedDate,
        startTime: "",
        endTime: "",
        notes: "",
      });
    }
  }, [isOpen, selectedDate, selectedRoomId, form, user]);

  // Mutación para crear una reserva
  const createBookingMutation = useMutation({
    mutationFn: async (bookingData: any) => {
      console.log("Enviando datos a API:", bookingData);
      const res = await apiRequest("POST", "/api/bookings", bookingData);
      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.message || "Error al crear la reserva");
      }
      return await res.json();
    },
    onSuccess: async (newBooking: Booking) => {
      console.log("Reserva creada con éxito:", newBooking);
      
      // Enfoque de invalidación de caché más agresivo
      try {
        console.log("Iniciando proceso de invalidación de caché completo...");
        
        // 1. Invalidar todas las consultas de reservas (enfoque general)
        await queryClient.invalidateQueries({ 
          queryKey: ['/api/bookings']
        });
        console.log("1. Invalidadas consultas generales de reservas");
        
        // 2. Invalidar específicamente las reservas del usuario actual
        await queryClient.invalidateQueries({ 
          queryKey: [`/api/users/${newBooking.userId}/bookings`] 
        });
        console.log(`2. Invalidadas consultas de reservas para usuario ${newBooking.userId}`);
        
        // 3. Invalidar específicamente para el usuario actual (administrador o el que hizo la reserva)
        if (user?.id) {
          await queryClient.invalidateQueries({ 
            queryKey: [`/api/users/${user.id}/bookings`] 
          });
          console.log(`3. Invalidadas consultas de reservas para usuario actual ${user.id}`);
        }
        
        // 4. Invalidar específicamente para la fecha de la reserva
        await queryClient.invalidateQueries({ 
          queryKey: ['/api/bookings', newBooking.date]
        });
        console.log(`4. Invalidadas consultas para fecha específica: ${newBooking.date}`);
        
        // 5. Invalidar para el consultorio específico
        await queryClient.invalidateQueries({ 
          queryKey: ['/api/rooms', newBooking.roomId]
        });
        console.log(`5. Invalidadas consultas para consultorio específico: ${newBooking.roomId}`);
        
        // 6. Invalidar todas las consultas de forma agresiva para calendario y disponibilidad
        console.log("6. Invalidando consultas relacionadas con calendario y salas:");
        
        // 6.1 Invalidar todas las consultas relacionadas con salas
        await queryClient.invalidateQueries({
          queryKey: ['/api/rooms']
        });
        console.log("   - Invalidadas consultas generales de salas");
        
        // 6.2 Invalidar todas las consultas relacionadas con disponibilidad
        await queryClient.invalidateQueries({
          predicate: (query) => {
            if (Array.isArray(query.queryKey) && 
                query.queryKey[0] === '/api/rooms' && 
                query.queryKey.length > 1 && 
                query.queryKey[2] === 'availability') {
              console.log(`   - Invalidada consulta de disponibilidad: ${JSON.stringify(query.queryKey)}`);
              return true;
            }
            return false;
          }
        });
        
        // 7. Finalmente, invalidar cualquier consulta que pueda estar relacionada con reservas (enfoque amplio)
        await queryClient.invalidateQueries({
          predicate: (query) => {
            if (Array.isArray(query.queryKey) && 
                (query.queryKey[0].includes('booking') || 
                 query.queryKey[0].includes('room'))) {
              console.log(`7. Invalidada consulta adicional: ${JSON.stringify(query.queryKey)}`);
              return true;
            }
            return false;
          }
        });
        
        console.log("Proceso de invalidación de caché completado con éxito");
      } catch (error) {
        console.error("Error al invalidar el caché:", error);
      }
      
      toast({
        title: "Reserva creada",
        description: "La reserva ha sido creada exitosamente",
      });
      
      if (onSuccess) onSuccess();
      onClose();
    },
    onError: (error: Error) => {
      console.error("Error al crear la reserva:", error);
      toast({
        title: "Error",
        description: error.message,
        variant: "destructive",
      });
      setIsSubmitting(false);
    },
  });

  // Función para manejar el envío del formulario
  const onSubmit = async (values: BookingFormValues) => {
    console.log("Formulario enviado con valores:", values);
    setIsSubmitting(true);
    
    try {
      // Convertir los tipos de datos necesarios
      // Corregir la fecha para asegurar que se envía en el formato correcto
      const bookingDate = formatDateForAPI(values.date);
      console.log("Fecha formateada para API:", bookingDate);
      
      // Primero verificamos si el consultorio está disponible para esa fecha y hora
      const roomId = parseInt(values.roomId);
      const startTime = values.startTime;
      const endTime = values.endTime;
      
      // Realizar una última comprobación de disponibilidad antes de enviar
      const response = await fetch(`/api/bookings?roomId=${roomId}&date=${bookingDate}`);
      let isAvailable = true;
      
      if (response.ok) {
        const existingBookings = await response.json();
        console.log("Verificando reservas existentes para crear:", existingBookings);
        
        // Verificar si hay alguna reserva que se superponga con la nueva
        const conflicts = existingBookings.filter((booking: Booking) => {
          // Ignorar reservas canceladas
          if (booking.status === "cancelled") return false;
          
          // Verificar superposición de horarios con horas como números
          const bookingStartHour = parseInt(booking.startTime.split(":")[0]);
          const bookingEndHour = parseInt(booking.endTime.split(":")[0]);
          const newStartHour = parseInt(startTime.split(":")[0]);
          const newEndHour = parseInt(endTime.split(":")[0]);
          
          // Calculamos la superposición basada en la hora (como número entero)
          const hasOverlap = (
            (newStartHour >= bookingStartHour && newStartHour < bookingEndHour) ||
            (newEndHour > bookingStartHour && newEndHour <= bookingEndHour) ||
            (newStartHour <= bookingStartHour && newEndHour >= bookingEndHour)
          );
          
          console.log(`Comparando con reserva ${booking.id}: ${booking.startTime}-${booking.endTime}, Resultado: ${hasOverlap ? 'Conflicto' : 'Sin conflicto'}`);
          return hasOverlap;
        });
        
        const hasConflict = conflicts.length > 0;
        console.log(`Resultado final para crear: ${hasConflict ? 'No disponible' : 'Disponible'}`);
        
        if (hasConflict) {
          toast({
            title: "Consultorio no disponible",
            description: "El consultorio ya está reservado para el horario seleccionado",
            variant: "destructive",
          });
          setIsSubmitting(false);
          return;
        }
      }
      
      // Si llegamos aquí, es que no hay conflictos
      // Asegurarse de que la fecha está en formato YYYY-MM-DD y no se pierde por timezone
      const dateObj = new Date(values.date);
      // Convertimos la fecha a string en formato ISO y tomamos solo la parte de la fecha (YYYY-MM-DD)
      const correctedDate = dateObj.toISOString().split('T')[0];
      
      console.log("Fecha original:", values.date);
      console.log("Fecha corregida para API:", correctedDate);
      
      // Obtener precio del consultorio para la reserva
      const selectedRoom = rooms?.find(r => r.id === roomId);
      const roomPrice = selectedRoom?.price || 0;
      
      const bookingData = {
        roomId,
        // Desde el servidor asignaremos automáticamente el usuario actual
        // Solo incluir userId si eres admin y estás creando para otro usuario
        ...(user?.role === 'admin' && values.userId ? { userId: parseInt(values.userId) } : {}),
        date: correctedDate, // Usar la fecha corregida
        startTime,
        endTime,
        notes: values.notes || "",
        status: "confirmed",
        // Restaurar opción de pago
        requiresPayment: true,
        paymentAmount: roomPrice
      };
      
      console.log("Datos de reserva a enviar:", bookingData);
      console.log("Usuario actual:", user?.id, user?.username);
      
      console.log("Enviando datos de reserva a API:", bookingData);
      await createBookingMutation.mutateAsync(bookingData);
    } catch (error) {
      console.error("Error en onSubmit:", error);
      setIsSubmitting(false);
    }
  };

  // Filtrar terapeutas (mostrar todos los usuarios que no sean admin)
  const therapists = users?.filter(u => u.role !== "admin") || [];

  // Función para verificar disponibilidad del consultorio cuando cambian campos relacionados
  const [checkingAvailability, setCheckingAvailability] = useState(false);
  const [isTimeSlotAvailable, setIsTimeSlotAvailable] = useState<boolean | null>(null);
  
  // Verificar disponibilidad cuando cambian los campos relevantes
  useEffect(() => {
    const roomId = form.getValues("roomId");
    const date = form.getValues("date");
    const startTime = form.getValues("startTime");
    const endTime = form.getValues("endTime");
    
    // Solo verificar si todos los campos necesarios tienen valor
    if (roomId && date && startTime && endTime) {
      checkRoomAvailability(parseInt(roomId), date, startTime, endTime);
    } else {
      // Reiniciar estado si falta algún campo
      setIsTimeSlotAvailable(null);
    }
  }, [form.watch("roomId"), form.watch("date"), form.watch("startTime"), form.watch("endTime")]);
  
  // Función para verificar disponibilidad del consultorio
  const checkRoomAvailability = async (roomId: number, date: Date, startTime: string, endTime: string) => {
    try {
      setCheckingAvailability(true);
      console.log(`Verificando disponibilidad para: Consultorio ${roomId}, Fecha ${formatDateForAPI(date)}, Hora ${startTime}-${endTime}`);
      
      const bookingDate = formatDateForAPI(date);
      const response = await fetch(`/api/bookings?roomId=${roomId}&date=${bookingDate}`);
      
      if (response.ok) {
        const existingBookings = await response.json();
        console.log("Reservas existentes:", existingBookings);
        
        // Verificar si hay alguna reserva que se superponga con la nueva
        const conflicts = existingBookings.filter((booking: Booking) => {
          // Ignorar reservas canceladas
          if (booking.status === "cancelled") return false;
          
          // Verificar superposición de horarios
          const bookingStartHour = parseInt(booking.startTime.split(":")[0]);
          const bookingEndHour = parseInt(booking.endTime.split(":")[0]);
          const newStartHour = parseInt(startTime.split(":")[0]);
          const newEndHour = parseInt(endTime.split(":")[0]);
          
          // Calculamos la superposición basada en la hora (como número entero)
          const hasOverlap = (
            (newStartHour >= bookingStartHour && newStartHour < bookingEndHour) ||
            (newEndHour > bookingStartHour && newEndHour <= bookingEndHour) ||
            (newStartHour <= bookingStartHour && newEndHour >= bookingEndHour)
          );
          
          console.log(`Comparando con reserva ${booking.id}: ${booking.startTime}-${booking.endTime}, Resultado: ${hasOverlap ? 'Conflicto' : 'Sin conflicto'}`);
          return hasOverlap;
        });
        
        const hasConflict = conflicts.length > 0;
        console.log(`Resultado final: ${hasConflict ? 'No disponible' : 'Disponible'}`);
        setIsTimeSlotAvailable(!hasConflict);
      } else {
        console.error("Error en la respuesta del servidor:", await response.text());
        setIsTimeSlotAvailable(null);
      }
    } catch (error) {
      console.error("Error al verificar disponibilidad:", error);
      setIsTimeSlotAvailable(null);
    } finally {
      setCheckingAvailability(false);
    }
  };
  
  // Verificar si se están cargando los datos
  const isLoading = isLoadingRooms || isLoadingUsers;

  console.log("Renderizando modal:", { isOpen, selectedRoomId, selectedDate, isLoading });
  
  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="max-w-md sm:max-w-lg max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Nueva Reserva</DialogTitle>
          <DialogDescription>
            Complete los detalles para agendar una nueva reserva de consultorio.
          </DialogDescription>
        </DialogHeader>

        {isLoading ? (
          <div className="flex justify-center py-8">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
          </div>
        ) : (
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              {/* Campo: Consultorio */}
              <FormField
                control={form.control}
                name="roomId"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Consultorio</FormLabel>
                    <Select
                      value={field.value}
                      onValueChange={field.onChange}
                      disabled={isSubmitting}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Seleccionar consultorio" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="max-h-[300px] overflow-y-auto">
                        {rooms?.map((room) => (
                          <SelectItem key={room.id} value={String(room.id)}>
                            {room.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Campo: Terapeuta (Solo visible para administradores) */}
              {user?.role === "admin" && (
                <FormField
                  control={form.control}
                  name="userId"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Terapeuta</FormLabel>
                      <Select
                        value={field.value}
                        onValueChange={field.onChange}
                        disabled={isSubmitting}
                      >
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Seleccionar terapeuta" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent className="max-h-[300px] overflow-y-auto">
                          {therapists.map((therapist) => (
                            <SelectItem key={therapist.id} value={String(therapist.id)}>
                              {therapist.fullName}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              )}

              {/* Campo: Fecha */}
              <FormField
                control={form.control}
                name="date"
                render={({ field }) => (
                  <FormItem className="flex flex-col">
                    <FormLabel>Fecha de la reserva</FormLabel>
                    <Calendar
                      mode="single"
                      selected={field.value}
                      onSelect={(date) => date && field.onChange(date)}
                      disabled={isSubmitting}
                      className="rounded-md border mx-auto"
                      initialFocus
                    />
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Campo: Hora de inicio */}
              <FormField
                control={form.control}
                name="startTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Hora de inicio</FormLabel>
                    <Select
                      value={field.value}
                      onValueChange={(value) => {
                        field.onChange(value);
                        
                        // Actualizar hora de fin automáticamente (una hora después)
                        const startIndex = OPERATING_HOURS.indexOf(value);
                        if (startIndex >= 0 && startIndex < OPERATING_HOURS.length - 1) {
                          form.setValue("endTime", OPERATING_HOURS[startIndex + 1]);
                        }
                      }}
                      disabled={isSubmitting}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Seleccionar hora de inicio" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="max-h-[300px] overflow-y-auto">
                        {OPERATING_HOURS.slice(0, -1).map((time) => (
                          <SelectItem key={time} value={time}>
                            {time}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Campo: Hora de finalización */}
              <FormField
                control={form.control}
                name="endTime"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Hora de finalización</FormLabel>
                    <Select
                      value={field.value}
                      onValueChange={field.onChange}
                      disabled={isSubmitting || !form.getValues("startTime")}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Seleccionar hora de finalización" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="max-h-[300px] overflow-y-auto">
                        {OPERATING_HOURS
                          .filter((time) => {
                            // Solo mostrar horas posteriores a la hora de inicio
                            const startTime = form.getValues("startTime");
                            if (!startTime) return false;
                            const startTimeHour = parseInt(startTime.split(":")[0]);
                            const currentTimeHour = parseInt(time.split(":")[0]);
                            // Mostrar todas las horas que sean mayores que la hora de inicio
                            return currentTimeHour > startTimeHour;
                          })
                          .map((time) => (
                            <SelectItem key={time} value={time}>
                              {time}
                            </SelectItem>
                          ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Indicador de disponibilidad */}
              {form.getValues("roomId") && form.getValues("startTime") && form.getValues("endTime") && (
                <div className="mt-4">
                  {checkingAvailability ? (
                    <div className="flex items-center space-x-2 text-gray-500">
                      <Loader2 className="h-4 w-4 animate-spin" />
                      <span>Verificando disponibilidad...</span>
                    </div>
                  ) : isTimeSlotAvailable === true ? (
                    <div className="flex items-center space-x-2 text-green-600">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                      </svg>
                      <span>El consultorio está disponible para el horario seleccionado</span>
                    </div>
                  ) : isTimeSlotAvailable === false ? (
                    <div className="flex items-center space-x-2 text-red-600">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clipRule="evenodd" />
                      </svg>
                      <span>El consultorio ya está reservado para el horario seleccionado</span>
                    </div>
                  ) : null}
                </div>
              )}

              <DialogFooter>
                <Button 
                  type="button" 
                  variant="outline" 
                  onClick={onClose}
                  disabled={isSubmitting}
                >
                  Cancelar
                </Button>
                <Button 
                  type="submit" 
                  disabled={isSubmitting || isTimeSlotAvailable === false}
                  className="gap-2"
                >
                  {isSubmitting && <Loader2 className="h-4 w-4 animate-spin" />}
                  Crear Reserva
                </Button>
              </DialogFooter>
            </form>
          </Form>
        )}
      </DialogContent>
    </Dialog>
  );
}